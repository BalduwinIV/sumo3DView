import groovy.json.JsonSlurper

pipeline {
  agent {
    kubernetes {
      inheritFrom 'my-agent-pod'
      yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: jnlp
    resources:
      limits:
        memory: "2Gi"
        cpu: "500m"
      requests:
        memory: "2Gi"
        cpu: "500m"
  - name: ubuntu-sumo
    image: ghcr.io/eclipse/eclipse-sumo-build-ubuntu:latest
    tty: true
    resources:
      limits:
        memory: "2Gi"
        cpu: "1"
      requests:
        memory: "2Gi"
        cpu: "1"
    command:
    - cat
    env:
    - name: "MAVEN_OPTS"
      value: "-Duser.home=/home/jenkins"
    volumeMounts:
    - name: settings-xml
      mountPath: /home/jenkins/.m2/settings.xml
      subPath: settings.xml
      readOnly: true
    - name: settings-security-xml
      mountPath: /home/jenkins/.m2/settings-security.xml
      subPath: settings-security.xml
      readOnly: true
    - name: m2-repo
      mountPath: /home/jenkins/.m2/repository
  volumes:
  - name: settings-xml
    secret:
      secretName: m2-secret-dir
      items:
      - key: settings.xml
        path: settings.xml
  - name: settings-security-xml
    secret:
      secretName: m2-secret-dir
      items:
      - key: settings-security.xml
        path: settings-security.xml
  - name: m2-repo
    emptyDir: {}
"""
    }
  }
  environment {
    GITHUB_TOKEN = credentials('github-bot-token')
    REPO_OWNER = "eclipse-sumo"
    REPO_NAME = "sumo"
    WORKFLOW_ID = "build-macos.yml"
    ARTIFACT_NAME = "macos-14-installer-unsigned"
  }
  stages {
    stage('Download macOS Installer Artifact') {
      steps {
        container('ubuntu-sumo') {
          script {
            // Step 1: Find the last successful workflow run
            def workflowRunsResponse = sh(
              script: 'curl -H "Authorization: Bearer ${GITHUB_TOKEN}" -s "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/${WORKFLOW_ID}/runs?status=success"',
              returnStdout: true
            ).trim()

            // Parse workflow runs JSON response using JsonSlurper
            def workflowRuns = new JsonSlurper().parseText(workflowRunsResponse)
            if (!workflowRuns.workflow_runs || workflowRuns.workflow_runs.size() == 0) {
              error("No successful workflow runs found for workflow: ${WORKFLOW_ID}")
            }

            def lastRunId = workflowRuns.workflow_runs[0].id

            // Step 2: Get the artifact list for the last successful run
            def artifactsResponse = sh(
              script: 'curl -H "Authorization: Bearer ${GITHUB_TOKEN}" -s "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs/' + "${lastRunId}" + '/artifacts"',
              returnStdout: true
            ).trim()

            // Parse artifacts JSON response using JsonSlurper
            def artifacts = new JsonSlurper().parseText(artifactsResponse)
            def artifact = artifacts.artifacts.find { it.name == ARTIFACT_NAME }
            if (!artifact) {
              error("Artifact '${ARTIFACT_NAME}' not found for run ID: ${lastRunId}")
            }

            // Step 3: Download the artifact
            sh 'curl -H "Authorization: Bearer ${GITHUB_TOKEN}" -L "' + "${artifact.archive_download_url}" + '" --output ${ARTIFACT_NAME}.zip'

            // Step 4: Extract the artifact
            sh "unzip -o ${ARTIFACT_NAME}.zip -d artifact"

            // Step 5: Create the entitlements file
            def entitlementsFile = "sumo.entitlement"
            writeFile file: entitlementsFile, text: '''
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.cs.allow-jit</key>
    <true/>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    <key>com.apple.security.cs.disable-executable-page-protection</key>
    <true/>
    <key>com.apple.security.cs.allow-dyld-environment-variables</key>
    <true/>
    <key>com.apple.security.cs.disable-library-validation</key>
    <true/>
    <key>com.apple.security.cs.debugger</key>
    <true/>
</dict>
</plist>'''

            // Step 6: Extract the .dmg file name dynamically
            def dmgFile = sh(
                script: "ls artifact/*.dmg",
                returnStdout: true
            ).trim()

            if (!dmgFile) {
                error("No .dmg file found in artifact directory")
            }

            // Extract the base name of the .dmg file (without the extension)
            def baseName = dmgFile.replaceAll(/\.dmg$/, "")

            // Define the signed DMG file name
            def signedDmgFile = "${baseName}-signed.dmg"

            // Step 7: Upload for signing
            sh """
            curl -o ${signedDmgFile} -F file=@${dmgFile} -F entitlements=@${entitlementsFile} \
                https://cbi.eclipse.org/macos/codesign/sign
            """

            // Verify signed file
            if (!fileExists(signedDmgFile)) {
                error("Signed DMG file not created: ${signedDmgFile}")
            }

            echo "Signed DMG file created successfully: ${signedDmgFile}"
          }
        }
      }
    }
  }
}
